---
title: "seesaw"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{seesaw}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(seesaw)
library(ggplot2)
library(sf)
library(GpGp)
```

### Load the Data

```{r}

data("full_table", package = "seesaw")
data("station_info", package = "seesaw")
data("shp_file", package = "seesaw")

```


1. Make a map of the average temperature at each station for the month of March 
2024.

```{r}
# Get list of station ids 
station_ids <- station_info$station_id

# Filter data to include only March 2024, find average March 2024 
# temperature for each station
march_data <- full_table[full_table$LST_DATE >= "2024-03-01" 
                         & full_table$LST_DATE <= "2024-03-31", ]
average_temps <- aggregate(march_data$T_DAILY_AVG,
                           by = list( march_data$WBANNO ),
                           FUN = mean )

# Create a new data frame with station ids, average temperatures,lat and lon
df <- data.frame(station_id = unique(march_data$WBANNO), 
                 average_temp = average_temps$x)
# Merge df with station_info to get lat and lon
df <- merge(df, station_info, by.x = "station_id", by.y = "station_id")

# Drop NAs
df <- df[complete.cases(df), ]

# Plot the USA shapefile and add the average temperature data as points
usa_boundary <- st_crop(st_make_valid(shp_file), xmin = -125, xmax = -66.93457, 
                    ymin = 22.396308, ymax = 49.384358)

df_sf <- st_as_sf(df, coords = c("longitude", "latitude"), crs = 
                    st_crs(usa_boundary))
coordinates <- st_coordinates(df_sf)
df_sf$x <- coordinates[,1]
df_sf$y <- coordinates[,2]

ggplot() +
  geom_sf(data = usa_boundary) +
  coord_sf(lims_method = "geometry_bbox") +
  geom_point(data = df_sf, aes(color = average_temp, x = x, y = y), size = 1) +
  theme_minimal() +
  labs(title = "Average Temperature for March 2024", 
       x = "Longitude", y = "Latitude") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_gradient(name = "Temperature (°C)", low = "blue", high = "red")
  

```

2. Fit a spatial model and plot an interpolated map of average temperatures for March 2024. Consider
including elevation in your model.

```{r}

res <- 50
spatial_model <- interpolate_grid("2024-03-01","2024-03-31","T_DAILY_AVG", res)
grid <- usagrid(res)
graph_interp(spatial_model, grid) + 
  labs( title = "Interpolated Average Temperatures for March 2024",
    x = "Longitude", y = "Latitude", 
    fill = "Temperature (°C)")

library("elevatr")
# Fit a spatial model with elevation
grid$elevation <- elevatr::get_elev_point(grid[, c("x", "y")], 
                                          prj = st_crs(usa_boundary))$elevation
y_dat <- full_table[(full_table$LST_DATE >= "2024-03-01") &
                             (full_table$LST_DATE <= "2024-03-31"), ]
y_dat$x <- y_dat$LONGITUDE
y_dat$y <- y_dat$LATITUDE
y_dat$elevation <- elevatr::get_elev_point(y_dat[, c("x", "y")], prj = st_crs(usa_boundary))$elevation
X <- model.matrix(~ elevation, data = y_dat)
# Store response variable
y <- y_dat[ , "T_DAILY_AVG"]
# Subset data frame and store locations
locs <- y_dat[, c("x", "y")]
# Create model matrix
# Fit the Gaussian process model
model <- GpGp::fit_model(y,locs, X, covfun_name = "matern_sphere",
                           start_parms = c(42.2746, 2.6493, 0.1902, 2.0873), 
                           silent = T)
Xpred <- model.matrix(~ elevation, data = grid)
locs_pred <- grid[, c("x", "y")]
preds <- GpGp::predictions(model,locs_pred, Xpred)
graph_interp(preds,grid)

```

3. Estimate the warmest and coldest day of the year for each station, and plot those days on two maps. Think carefully about how to represent the days numerically. 

In your report, describe the statistical analysis that you used for estimating the warmest and coldest days at each station, including writing down any statistical models in mathematical notation. Be sure to define all your symbols and assumptions. 

Interpolate maps of the warmest and coldest days, and plot the interpolated maps of warmest and coldest days. 

```{r}

# Create a function for finding the estimated warmest and coldest days of year
# for a given station
warmest_coldest <- function(station_id){
  cycle <- yearly_cycle_station(station_id, "T_DAILY_AVG")
  warmest_day <- cycle$DOY[which.max(cycle$Expected_T_DAILY_AVG)]
  coldest_day <- cycle$DOY[which.min(cycle$Expected_T_DAILY_AVG)]
  c(warmest_day, coldest_day)
}

# Preallocate the data frame
warmest_coldest_days <- data.frame(station_id = station_ids, 
                                   warmest_day = numeric(length(station_ids)), 
                                   coldest_day = numeric(length(station_ids)))

# Loop through each station
for (i in 1:length(station_ids)){
  # Assign values directly without using c()
  warmest_coldest_days[i, c("warmest_day", "coldest_day")] <- 
    warmest_coldest(station_ids[i])
}

# Plot the shapefile and add the warmest day data as points
df_warmest_coldest <- merge(warmest_coldest_days, station_info, 
                    by.x = "station_id", by.y = "station_id")
df_warm_cold_sf <- st_as_sf(df_warmest_coldest, 
                          coords = c("longitude", "latitude"), 
                          crs = st_crs(usa_boundary))

coordinates <- st_coordinates(df_warm_cold_sf)
df_warm_cold_sf$x <- coordinates[,1]
df_warm_cold_sf$y <- coordinates[,2]

ggplot() +
  geom_sf(data = usa_boundary) +
  coord_sf(lims_method = "geometry_bbox") +
  geom_point(data = df_warm_cold_sf, 
             aes(color = warmest_day, x = x, y = y), size = 1) +
  theme_minimal() +
  labs(title = "Warmest Day of the Year for Each Station", 
       x = "Longitude", y = "Latitude") +
  scale_color_gradient(name = "Day of Year") + #, low = "blue", high = "red") +
  theme(plot.title = element_text(hjust = 0.5))

# Plot the shapefile and add the coldest day data as points
ggplot() +
  geom_sf(data = usa_boundary) +
  coord_sf(lims_method = "geometry_bbox") +
  geom_point(data = df_warm_cold_sf, 
             aes(color = coldest_day, x = x, y = y), size = 1) +
  theme_minimal() +
  labs(title = "Coldest Day of the Year for Each Station", 
       x = "Longitude", y = "Latitude") + 
  scale_color_gradient(name = "Day of Year") + #, low = "blue", high = "red") +
  theme(plot.title = element_text(hjust = 0.5))

```

Statistical Model:

The estimated average warmest and coldest day of the year was calculated by fitting a sinusoidal model to the daily average temperature data for each station. The model is given by:

$Y_i = \beta_0 + \beta_1 * \sin(2\pi d/365) + \beta_2*\cos(2\pi d/365) + \epsilon_i$

where $Y_i$ is the daily average temperature, $d$ is the day of the year, and $\epsilon_i$ is the error term. The estimated warmest day of the year is the day with the highest expected temperature, and the estimated coldest day of the year is the day with the lowest expected temperature.

Assumptions:
1. The daily average temperature data is sinusoidal with a period of 365 days.
2. The daily average temperature data is stationary over time.
3. The error term is normally distributed with mean 0 and constant variance.

```{r}

# Interpolate maps of the warmest and coldest days
df_warmest_coldest$longitude <- as.numeric(df_warmest_coldest$longitude)
df_warmest_coldest$latitude <- as.numeric(df_warmest_coldest$latitude)
locs <- df_warmest_coldest[, c("longitude", "latitude")]

# Make a dataframes of locations and y_cold/y_warm
cold_dataset <- df_warmest_coldest[,c("longitude", "latitude", "coldest_day")]
warm_dataset <- df_warmest_coldest[,c("longitude", "latitude", "warmest_day")]
# Drop repeated rows
cold_dataset <- cold_dataset[!duplicated(cold_dataset),]
warm_dataset <- warm_dataset[!duplicated(warm_dataset),]
X_cold <- cbind(1, cold_dataset[, c("longitude", "latitude")])
X_warm <- cbind(1, warm_dataset[, c("longitude", "latitude")])
y_cold <- cold_dataset$coldest_day
y_warm <- warm_dataset$warmest_day
locs_cold <- cold_dataset[, c("longitude", "latitude")]
locs_warm <- warm_dataset[, c("longitude", "latitude")]

# Fit model
warm_model <- fit_model(y_warm, locs_warm, X_warm, 
                        covfun_name = "matern_sphere", 
                        silent = T)

# Problem is that cold_model only has one intercept, it should have 3
cold_model <- fit_model(y_cold, locs_cold, X_cold, 
                        covfun_name = "exponential_sphere",
                            silent = T)

# Create prediction matrix
grid <- usagrid(100)
Xpred <- cbind(1, grid[, c("x", "y")])
pred_locs <- grid[, c("x", "y")]

# Make predictions
warm_pred <- predictions(warm_model,pred_locs, Xpred)
cold_pred <- predictions(cold_model,pred_locs, Xpred)

# Plot interpolations
graph_interp(warm_pred, grid) + 
  labs( title = "Interpolated Warmest Day of the Year",
    x = "Longitude", y = "Latitude", 
    fill = "Day of Year") 
# + scale_color_gradient(name = "Day of Year", low = "blue", high = "red")
graph_interp(cold_pred, grid) + 
  labs( title = "Interpolated Coldest Day of the Year",
    x = "Longitude", y = "Latitude", 
    fill = "Day of Year")
# + scale_color_gradient(name = "Day of Year", low = "blue", high = "red")
```


4. Make a single plot of the estimated yearly cycles for 10 different stations, highlighting a diversity of climates around the contiguous USA. Your plot should clearly indicate which cycle is from which station. 

```{r}

# Select 10 stations from around the contiguous USA
# ( Maine, Washington, Arizona, Wyoming, Oklahoma, Texas, Kentucky, Florida, 
#   Michigan, Pennsylvania )
stations <- c("94645", "04223", "53169", "04131", "53182", "12987", "63849", 
              "92826", "54810", "03761")
states <- c("Maine", "Washington", "Arizona", "Wyoming", "Oklahoma", "Texas", 
           "Kentucky", "Florida", "Michigan", "Pennsylvania")
# Select 10 colors
cols <- c("chartreuse1", "darkcyan", "dodgerblue4", "goldenrod1", "darkorange1",
          "deeppink3", "green4", "mediumpurple", "midnightblue", "firebrick3")
# Initialize plot
plt <- ggplot() + 
  labs(title = "Estimated Yearly Cycles", 
       x = "DOY", y = "Expected_T_DAILY_AVG")
# Calculate and plot estimated yearly cycle for each station
for (i in 1:10){
  cycle <- yearly_cycle_station(stations[i])
  cycle$state <- states[i]
  plt <- plt + geom_line(data = cycle, 
                           aes(x = DOY, y = Expected_T_DAILY_AVG,
                               color = state))
}
# Add legend
plt <- plt + scale_color_manual(name = "State with Station", breaks = states, 
                                values = setNames(cols, states))
plt
```

5. Estimate the trend over the years for each station, in units of degrees Fahrenheit per year, and plot the trend values on a map. Indicate visually on your map which of the trends are statistically significant.

In your report, write the statistical model that you used in mathematical notation. Be sure to define all your symbols and assumptions.

Interpolate the estimated trends to a grid, and plot them on a map. For the interpolations, you may consider using only the trend estimates whose standard errors are sufficiently small. 

```{r}
# Find the temperature trends for each station (since 2000)
temp_trends <- trend_of_temps()

# Create a new data frame with station ids, temperature trend, lat and long
station_trends <- data.frame(station_id = temp_trends$station_id, 
                             trend = temp_trends$trend_Overall)
# Merge df with station_info to get lat and lon
station_trends <- merge(station_trends, station_info, by.x = "station_id", 
                        by.y = "station_id")

# Determine which trends are statistically significant
sd <- var(station_trends$trend)
n <- length(station_trends$trend)
test_statistics <- (station_trends$trend - 0) / ( sd/sqrt(n) )
p_vals <- pt( test_statistics, df = n - 1, lower.tail = FALSE )

determine_significance <- function(pval){
  
  # Assume all pvals are greater than 0.05
  signif <- " "
  # Greater than 0.01, less than 0.05
  if (pval <= 0.05 & pval > 0.01) {
    signif <- "*"
  } else if (pval <= 0.01 & pval > 0.001) {
  # Greater than 0.001, less than 0.01
    signif <- "**"
  } else if (pval <= 0.001) {
  # Less than 0.001
    signif <- "***"
  }
  return(signif)
}

station_trends$signif <- sapply(p_vals, determine_significance)


# Plot the USA shapefile
usa_boundary <- st_crop(st_make_valid(shp_file), xmin = -125, xmax = -66.93457, 
                    ymin = 22.396308, ymax = 49.384358)

station_trends_sf <- st_as_sf(station_trends, 
                              coords = c("longitude", "latitude"), 
                              crs = st_crs(usa_boundary))
coordinates <- st_coordinates(station_trends_sf)
station_trends_sf$x <- coordinates[,1]
station_trends_sf$y <- coordinates[,2]

# Plot overall trends
signifs = c(" ", "*", "**", "***")
signif.codes <- c("p > 0.05", "0.01 < p <= 0.05", "0.001 < p < 0.01", 
                  "p < 0.001")
ggplot() +
  geom_sf(data = usa_boundary) +
  coord_sf(lims_method = "geometry_bbox") +
  geom_point(data = station_trends_sf, 
             aes(color = trend, x = x, y = y, shape = signif), 
             size = 1) + theme_minimal() +
  labs(title = "Temperature Trends Since 2000", 
       x = "Longitude", y = "Latitude") +
  scale_color_gradient(name = "Trend (°C/Year)", low = "blue", high = "red") +
  scale_shape_discrete(name = "Significance", breaks = signifs, 
                                labels = signif.codes) +
  theme(plot.title = element_text(hjust = 0.5))
  

```

Statistical Model:

The estimated trend over the years for each station was calculated by fitting a linear model for each month of the year and taking the average of the slope coefficients from each linear model. This is given by:

$ estimated trend = ( \sum_(i = 1)^12 (\beta_1)_i )/ 12 $

where $(\beta_1)_i$ denotes the slope coefficient for ith month, and is derived from the model:

$Y_i = \beta_0 + \beta_1 *d + \epsilon_i$

where $Y_i$ is the daily average temperature, $d$ is the day of the year, and $\epsilon_i$ is the error term. 

Assumptions:
1. The change in temperature over the years can be modeled linearly. Further, we assume that the the change in monthly temperatures overall the years follows a linear trend as well.
2. The overall trend for each month contributes equal to the station’s trend overall (that is, each month’s trend is equally indicative of the trend overall)
3. The error term is normally distributed with mean 0 and constant variance.

To determine statistical significance, we assume that the temperature trends of stations are normally distributed with mean 0, indicating the temperature has not changed over the years. We run a t-test with significance level $\alpha = 0.05$ to determine which trends are significant.

```{r}
# Interpolate trends for contiguous US
y <- station_trends$trend
locs <- station_trends[, c("longitude", "latitude")]
locs$longitude <- as.numeric(locs$longitude)
locs$latitude <- as.numeric(locs$latitude)
X <- cbind(1, locs)

# Fit model
trend_model <- fit_model(y, locs, X, covfun_name = "matern_sphere", 
                        silent = T)
grid <- usagrid(100)

# Create prediction matrix
Xpred <- cbind(1, grid[, c("x", "y")])
pred_locs <- grid[, c("x", "y")]

# Make predictions
trend_preds <- predictions(trend_model,pred_locs, Xpred)

# Plot interpolations
graph_interp(trend_preds, grid) + 
  labs( title = "Interpolated Trend Over the Years",
    x = "Longitude", y = "Latitude", 
    fill = "Trend (°C/Year)")

```

6. Find a reputable source for the average temperature trend in the contiguous USA over the past 20 years, and compare your results to the source's.

Reputable Source: US EPA 
https://www.epa.gov/climate-indicators/climate-change-indicators-us-and-global-temperature

The EPA reports that the average temperature in the contiguous US has risen by 0.55°F per decade since 1981. This is equivalent to 0.306°C per decade. Our model estimates the average temperature trend in the contiguous US to be roughly 0.88°C per decade. However, this is largely due to the fact that we are only considering the temperature trends since 2000, where temperature has been increasing even faster. Additionally, it is the case that the vast majority of the US is increasing at a rate lower than 0.88°C per decade, while stations in the Southwest are increasing at a much greater rate. 




